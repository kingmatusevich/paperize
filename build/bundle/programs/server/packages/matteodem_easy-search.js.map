{"version":3,"sources":["matteodem:easy-search/lib/easy-search-common.js","matteodem:easy-search/lib/easy-search-convenience.js","matteodem:easy-search/lib/searchers/mongo.js","matteodem:easy-search/lib/easy-search-server.js","matteodem:easy-search/lib/searchers/elastic-search.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,2B;AACA,e;;AAEA,e;AACA,c;AACA,2C;AACA,sB;AACA,yB;AACA,iB;AACA,mB;AACA,0B;AACA,wB;AACA,+B;AACA,mB;AACA,mC;AACA,oB;AACA,Q;AACA,mC;AACA,4B;AACA,kC;AACA,uD;AACA,S;;AAEA,kB;AACA,Q;AACA,oC;AACA,kE;AACA,6B;AACA,S;;AAEA,gC;AACA,Q;AACA,6B;AACA,wD;;AAEA,kB;AACA,2B;AACA,S;;AAEA,iB;AACA,Q;AACA,4C;AACA,uB;AACA,Q;AACA,S;AACA,yD;AACA,4D;AACA,Q;AACA,qC;AACA,gC;AACA,yB;AACA,S;AACA,kD;AACA,oE;AACA,O;AACA,M;;AAEA,8C;;AAEA,yB;AACA,yC;AACA,0D;AACA,oB;AACA,oB;AACA,yB;AACA,4B;AACA,uB;AACA,sB;;AAEA,iH;;AAEA,yC;AACA,0F;AACA,O;;AAEA,qC;AACA,8D;AACA,sE;AACA,wC;;AAEA,wB;AACA,wB;AACA,O;;AAEA,8E;;AAEA,6F;;AAEA,yD;;AAEA,6C;AACA,sD;AACA,oD;AACA,sC;AACA,O;;AAEA,yC;AACA,8B;AACA,uF;AACA,O;;AAEA,gF;AACA,8F;AACA,oD;AACA,2B;AACA,S;;AAEA,qC;AACA,gD;AACA,kB;AACA,iC;AACA,8B;AACA,0D;AACA,gE;AACA,Y;AACA,mC;AACA,0D;AACA,kE;AACA,Y;AACA,mC;AACA,6D;AACA,W;AACA,S;AACA,Q;;AAEA,uC;AACA,6B;AACA,S;;AAEA,2B;AACA,O;;AAEA,2D;AACA,6C;AACA,O;AACA,G;;AAEA,mE;AACA,2B;AACA,sD;AACA,kG;AACA,M;AACA,G;;AAEA,wB;AACA,O;AACA,6D;AACA,M;AACA,+B;AACA,8B;AACA,6B;AACA,O;AACA,wD;AACA,gC;AACA,kC;;AAEA,uC;AACA,wF;AACA,O;;AAEA,qD;AACA,M;;AAEA,O;AACA,gE;AACA,M;AACA,+B;AACA,8B;AACA,0B;AACA,O;AACA,2D;AACA,8C;AACA,kC;AACA,oC;AACA,O;;AAEA,uC;AACA,wF;AACA,O;;AAEA,wD;AACA,M;AACA,G;;;AAGA,K;AACA,kF;AACA,I;AACA,mE;AACA,yE;AACA,yE;AACA,I;AACA,K;AACA,iB;;AAEA,U;AACA,O;AACA,iC;AACA,M;AACA,gC;AACA,O;AACA,qC;AACA,gB;AACA,M;AACA,O;AACA,6B;AACA,M;AACA,8B;AACA,2B;AACA,O;AACA,sC;AACA,2B;;AAEA,mD;AACA,sC;AACA,wD;AACA,oC;AACA,O;AACA,M;AACA,O;AACA,6B;AACA,M;AACA,2B;AACA,8B;AACA,O;AACA,oD;AACA,6C;AACA,6B;;AAEA,0B;AACA,iF;AACA,iE;;AAEA,8B;;AAEA,mE;AACA,8C;AACA,O;;AAEA,wF;AACA,M;AACA,O;AACA,wB;AACA,M;AACA,wD;AACA,iE;AACA,sE;AACA,oE;AACA,O;AACA,iE;AACA,kB;AACA,8B;AACA,iC;;AAEA,0B;AACA,kC;AACA,6B;AACA,gD;;AAEA,2D;AACA,wF;AACA,O;;AAEA,yC;AACA,0F;AACA,O;;AAEA,+G;;AAEA,0C;AACA,M;AACA,O;AACA,+C;AACA,M;AACA,2B;AACA,uB;AACA,kB;AACA,O;AACA,kC;AACA,2B;AACA,M;AACA,O;AACA,wC;AACA,O;AACA,gC;AACA,qB;AACA,M;AACA,O;AACA,mC;AACA,M;AACA,2B;AACA,uB;AACA,kB;AACA,O;AACA,qC;AACA,6B;AACA,M;AACA,O;AACA,8B;AACA,O;AACA,kC;AACA,uB;AACA,M;AACA,O;AACA,8D;AACA,M;AACA,oC;AACA,sB;AACA,O;AACA,gD;AACA,0D;;AAEA,wC;AACA,oD;AACA,S;AACA,M;AACA,O;AACA,4D;AACA,kE;AACA,gD;AACA,M;AACA,mE;AACA,wE;AACA,mE;AACA,kF;AACA,sE;AACA,uD;AACA,O;AACA,gD;AACA,yB;AACA,sC;AACA,iD;;AAEA,+B;AACA,M;AACA,O;AACA,gF;AACA,M;AACA,kE;AACA,O;AACA,6C;AACA,4C;AACA,+D;AACA,M;AACA,O;AACA,0E;AACA,M;AACA,4C;AACA,O;AACA,uD;AACA,0B;;AAEA,uC;AACA,8B;AACA,S;;AAEA,wB;AACA,K;AACA,I;AACA,K;;;;;;;;;;;;;;;;;;;ACvWA,yE;AACA,6B;AACA,iB;AACA,G;;AAEA,8D;AACA,wB;AACA,oB;AACA,M;AACA,E;;AAEA,sB;AACA,6C;AACA,wB;;AAEA,0D;AACA,gB;AACA,K;;AAEA,gJ;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;ACrBA,e;AACA,K;AACA,2B;AACA,I;AACA,gB;AACA,mB;AACA,oB;AACA,K;AACA,kD;AACA,oD;AACA,+E;AACA,6E;AACA,sC;;AAEA,4B;AACA,iD;AACA,O;;AAEA,gC;AACA,qD;AACA,gE;AACA,S;AACA,Q;AACA,K;AACA,I;AACA,K;AACA,I;AACA,kD;AACA,I;AACA,yB;AACA,iC;AACA,4B;AACA,+B;AACA,sB;AACA,K;AACA,+D;AACA,e;AACA,c;AACA,e;AACA,e;AACA,iB;AACA,oB;AACA,wC;;AAEA,6B;AACA,a;AACA,K;;AAEA,wC;;AAEA,yE;AACA,kD;;AAEA,oB;AACA,uC;AACA,K;;AAEA,qB;AACA,8C;AACA,M;;AAEA,+B;AACA,0F;AACA,K;;AAEA,uB;AACA,wC;AACA,K;;AAEA,0B;AACA,0C;AACA,K;;AAEA,iC;AACA,kC;AACA,kC;AACA,O;;AAEA,2D;AACA,K;;AAEA,4D;;AAEA,0B;AACA,2C;AACA,kB;AACA,6B;AACA,S;AACA,mD;AACA,S;AACA,Q;;AAEA,wD;;AAEA,iB;AACA,kC;AACA,iE;AACA,Q;AACA,Y;AACA,8D;AACA,wE;;;AAGA,iB;AACA,2D;AACA,gC;AACA,Q;AACA,K;;AAEA,iC;AACA,wB;AACA,K;;AAEA,mB;AACA,I;AACA,K;AACA,8D;AACA,I;AACA,yB;AACA,iC;AACA,oC;AACA,I;AACA,sB;AACA,K;AACA,iE;AACA,iD;AACA,kD;AACA,yD;AACA,sC;AACA,8E;AACA,kD;AACA,O;;AAEA,sF;AACA,oB;AACA,iB;AACA,U;;AAEA,0B;AACA,+D;AACA,O;;AAEA,iD;AACA,4B;;AAEA,uC;AACA,mD;AACA,8C;AACA,iD;AACA,S;;AAEA,yC;AACA,S;;AAEA,sB;AACA,K;AACA,I;AACA,K;AACA,sE;AACA,I;AACA,yB;AACA,kB;AACA,K;AACA,mC;AACA,sB;AACA,G;AACA,E;;AAEA,sB;AACA,kD;AACA,6B;AACA,iD;AACA,C;;;;;;;;;;;;;;;;;;;;AC5KA,a;AACA,iD;;AAEA,+B;AACA,yB;AACA,E;;AAEA,G;AACA,0C;AACA,E;AACA,4B;AACA,G;AACA,0C;AACA,yC;AACA,6B;AACA,8D;AACA,sE;AACA,G;;AAEA,sB;AACA,E;;AAEA,G;AACA,8B;AACA,yF;AACA,E;AACA,iC;AACA,G;AACA,iD;AACA,kC;AACA,E;;AAEA,G;AACA,qE;AACA,I;AACA,wB;AACA,E;AACA,oB;AACA,G;AACA,gE;AACA,oB;;AAEA,mC;AACA,6B;AACA,K;;AAEA,kB;AACA,E;;AAEA,gB;AACA,K;AACA,oD;AACA,I;AACA,yB;AACA,iC;AACA,4B;AACA,K;AACA,sD;AACA,wB;AACA,gC;AACA,2B;AACA,0D;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC/DA,a;;AAEA,0C;AACA,+C;;AAEA,G;AACA,wC;AACA,E;AACA,0D;AACA,mB;AACA,G;AACA,2B;AACA,kB;;AAEA,qC;AACA,6G;AACA,K;;AAEA,gB;AACA,C;;AAEA,6C;AACA,K;AACA,2C;AACA,I;AACA,yB;AACA,wB;AACA,uB;AACA,yB;AACA,2B;AACA,K;AACA,2D;AACA,iC;AACA,6C;;AAEA,qC;AACA,2B;AACA,K;;AAEA,mB;AACA,0C;AACA,iC;AACA,uB;AACA,c;AACA,gB;AACA,6B;AACA,gB;AACA,oD;AACA,yB;AACA,O;;AAEA,iC;AACA,gF;AACA,kD;AACA,O;AACA,O;AACA,I;AACA,K;AACA,8D;AACA,I;AACA,yB;AACA,4B;AACA,K;AACA,kD;AACA,6B;AACA,yC;;AAEA,gE;AACA,uF;AACA,K;;AAEA,8B;;AAEA,8C;AACA,oC;AACA,mF;AACA,Q;AACA,8B;AACA,2D;AACA,2G;AACA,Q;AACA,8B;AACA,+C;AACA,sB;AACA,0B;AACA,gB;AACA,uC;AACA,6B;AACA,qE;AACA,W;AACA,W;AACA,O;AACA,O;AACA,I;AACA,K;AACA,0D;AACA,I;AACA,yB;AACA,qB;AACA,K;AACA,uC;AACA,sD;;AAEA,8D;AACA,4B;;AAEA,gC;AACA,yB;AACA,O;;AAEA,iD;AACA,8B;AACA,O;;AAEA,Y;AACA,0B;AACA,+B;AACA,M;AACA,I;AACA,K;AACA,wD;AACA,I;AACA,yB;AACA,iC;AACA,4B;AACA,+B;AACA,iB;AACA,K;AACA,+D;AACA,gB;AACA,kB;AACA,yB;AACA,wC;;AAEA,6B;AACA,a;AACA,K;;AAEA,e;AACA,kD;AACA,M;;AAEA,yB;AACA,uC;AACA,K;;AAEA,qD;;AAEA,+B;AACA,wD;AACA,yC;AACA,O;;AAEA,4C;AACA,K;;AAEA,2C;AACA,iD;AACA,6C;AACA,K;;AAEA,8B;;AAEA,yC;AACA,qE;AACA,a;AACA,K;;AAEA,+C;AACA,2C;AACA,mB;AACA,qB;AACA,2B;AACA,wB;AACA,+B;AACA,kB;AACA,qD;AACA,2B;AACA,e;AACA,O;;AAEA,mC;AACA,0C;AACA,O;;AAEA,0B;AACA,O;;AAEA,sB;AACA,I;AACA,K;AACA,gE;AACA,I;AACA,4B;AACA,iC;AACA,kB;AACA,K;AACA,qD;AACA,Y;AACA,2B;AACA,iC;AACA,kC;AACA,O;AACA,M;AACA,I;AACA,K;AACA,gE;AACA,I;AACA,4B;AACA,kB;AACA,K;AACA,sC;AACA,yB;AACA,G;AACA,G;;AAEA,2B;AACA,yC","file":"/packages/matteodem_easy-search.js","sourcesContent":["EasySearch = (function () {\n  'use strict';\n\n  var ESCounts,\n    Searchers,\n    indexes = {/** @see defaultOptions */},\n    defaultOptions = {\n      'format' : 'mongo',\n      'skip' : 0,\n      'limit' : 10,\n      'use' : 'minimongo',\n      'reactive' : true,\n      'useTextIndexes' : false,\n      'props' : {},\n      'permission'  : function () {\n        return true;\n      },\n      'transform' : function () {},\n      'sort' : function () {\n        if (Searchers[this.use]) {\n          return Searchers[this.use].defaultSort(this);\n        }\n\n        return {};\n      },\n      'reactiveSort' : function () {\n        if ('minimongo' === this.use || 'mongo-db' === this.use) {\n          return this.sort();\n        }\n\n        return ['_sortedOrder'];\n      },\n      'count' : function () {\n        var doc = ESCounts.findOne({ _id : this.name });\n\n        if (doc) {\n          return doc.count;\n        }\n\n        return 0;\n      },\n      'changeResults' : function (results) {\n        return results;\n      },\n      /**\n       * When using elastic-search it's the query object,\n       * while using with mongo-db it's the selector object.\n       *\n       * @param {String} searchString\n       * @param {Object} options\n       * @return {Object}\n       */\n      'query' : function (searchString, options) {\n        return Searchers[this.use].defaultQuery(this, searchString);\n      }\n    };\n\n  ESCounts = new Mongo.Collection('esCounts');\n\n  /** Helper Functions */\n  function setUpPublication(name, opts) {\n    Meteor.publish(name + '/easySearch', function (conf) {\n      var resultSet,\n        resultArray,\n        findOptions = {},\n        publishScope = this,\n        resultIds = [],\n        publishHandle;\n\n      check(conf, { value: Match.Optional(String), skip: Number, limit: Match.Optional(Number), props: Object });\n\n      if(!(indexes[name].permission())) {\n        throw new Meteor.Error('not-allowed', \"You're not allowed to search this index!\");\n      }\n\n      indexes[name].skip = conf.skip;\n      indexes[name].limit = conf.limit || indexes[name].limit;\n      indexes[name].props = _.extend(indexes[name].props, conf.props);\n      indexes[name].publishScope = this;\n\n      if (!conf.value) {\n        conf.value = '';\n      }\n\n      resultSet = Searchers[opts.use].search(name, conf.value, indexes[name]);\n\n      ESCounts.update({ _id: name }, { $set: { count: resultSet.total } }, { upsert: true });\n\n      if (!resultSet.results.length) return this.ready();\n\n      if (_.isObject(resultSet.results[0])) {\n        resultIds = _.pluck(resultSet.results, '_id');\n      } else if (_.isString(resultSet.results[0])) {\n        resultIds = resultSet.results;\n      }\n\n      // properly observe the collection!\n      if (opts.returnFields) {\n        findOptions.fields = EasySearch._transformToFieldSpecifiers(opts.returnFields);\n      }\n\n      // TODO: this doesn't work properly, that's why resultIds are used for now\n      // see http://stackoverflow.com/questions/3142260/order-of-responses-to-mongodb-in-query\n      resultArray = _.map(resultIds, function (id) {\n        return { _id: id };\n      });\n\n      publishHandle = opts.collection\n        .find({ $or: resultArray }, findOptions)\n        .observe({\n          added: function (doc) {\n            doc._index = name;\n            doc._sortedOrder = resultIds.indexOf(doc._id);\n            publishScope.added('esSearchResults', doc._id, doc);\n          },\n          changed: function (doc) {\n            doc._sortedOrder = resultIds.indexOf(doc._id);\n            publishScope.changed('esSearchResults', doc._id, doc);\n          },\n          removed: function (doc) {\n            publishScope.removed('esSearchResults', doc._id);\n          }\n        }\n      );\n\n      publishScope.onStop(function () {\n        publishHandle.stop();\n      });\n\n      publishScope.ready();\n    });\n\n    Meteor.publish(name + '/easySearchCount', function () {\n      return ESCounts.find({ '_id' : name });\n    });\n  }\n\n  function extendTransformFunction(collection, originalTransform) {\n    return function (doc) {\n      var transformedDoc = collection._transform(doc);\n      return _.isFunction(originalTransform) ? originalTransform(transformedDoc) : transformedDoc;\n    };\n  }\n\n  if (Meteor.isClient) {\n    /**\n     * find method to let users interact with search results.\n     *\n     * @param {Object} selector\n     * @param {Object} options\n     * @returns {MongoCursor}\n     */\n    defaultOptions.find = function (selector, options) {\n      selector = selector || {};\n      selector._index = this.name;\n\n      if (this.collection._transform) {\n        options.transform = extendTransformFunction(this.collection, options.transform);\n      }\n\n      return ESSearchResults.find(selector, options);\n    };\n\n    /**\n     * findOne method to let users interact with search results.\n     *\n     * @param {Object} selector\n     * @param {Object} options\n     * @returns {Document}\n     */\n    defaultOptions.findOne = function (selector, options) {\n      if (_.isObject(selector) || !selector) {\n        selector = selector || {};\n        selector._index = this.name;\n      }\n\n      if (this.collection._transform) {\n        options.transform = extendTransformFunction(this.collection, options.transform);\n      }\n\n      return ESSearchResults.findOne(selector, options);\n    };\n  }\n\n\n  /**\n   * Searchers contains all engines that can be used to search content, until now:\n   *\n   * minimongo (client): Client side collection for reactive search\n   * elastic-search (server): Elastic search server to search with (fast)\n   * mongo-db (server): MongoDB on the server to search (more convenient)\n   *\n   */\n  Searchers = {};\n\n  return {\n    /**\n     * Placeholder config method.\n     *\n     * @param {Object} newConfig\n     */\n    'config' : function (newConfig) {\n      return {};\n    },\n    /**\n     * Simple logging method.\n     *\n     * @param {String} message\n     * @param {String} type\n     */\n    'log' : function (message, type) {\n      type = type || 'log';\n\n      if (console && _.isFunction(console[type])) {\n        return console[type](message);\n      } else if (console && _.isFunction(console.log)) {\n        return console.log(message);\n      }\n    },\n    /**\n     * Create a search index.\n     *\n     * @param {String} name\n     * @param {Object} options\n     */\n    'createSearchIndex' : function (name, options) {\n      check(name, Match.OneOf(String, null));\n      check(options, Object);\n\n      options.name = name;\n      options.field = _.isArray(options.field) ? options.field : [options.field];\n      indexes[name] = _.extend(_.clone(defaultOptions), options);\n\n      options = indexes[name];\n\n      if (Meteor.isServer && EasySearch._usesSubscriptions(name)) {\n        setUpPublication(name, indexes[name]);\n      }\n\n      Searchers[options.use] && Searchers[options.use].createSearchIndex(name, options);\n    },\n    /**\n     * Perform a search.\n     *\n     * @param {String} name             the search index\n     * @param {String} searchString     the string to be searched\n     * @param {Object} options          defined with createSearchIndex\n     * @param {Function} callback       optional callback to be used\n     */\n    'search' : function (name, searchString, options, callback) {\n      var results,\n        index = indexes[name],\n        searcherType = index.use;\n\n      check(name, String);\n      check(searchString, String);\n      check(options, Object);\n      check(callback, Match.Optional(Function));\n\n      if (\"undefined\" === typeof Searchers[searcherType]) {\n        throw new Meteor.Error(500, \"Couldnt search with type: '\" + searcherType + \"'\");\n      }\n\n      if(!(indexes[name].permission())) {\n        throw new Meteor.Error('not-allowed', \"You're not allowed to search this index!\");\n      }\n\n      results = Searchers[searcherType].search(name, searchString, _.extend(indexes[name], options), callback);\n\n      return index.changeResults(results);\n    },\n    /**\n     * Retrieve a specific index configuration.\n     *\n     * @param {String} name\n     * @return {Object}\n     * @api public\n     */\n    'getIndex' : function (name) {\n      return indexes[name];\n    },\n    /**\n     * Retrieve all index configurations\n     */\n    'getIndexes' : function () {\n      return indexes;\n    },\n    /**\n     * Retrieve a specific Seacher.\n     *\n     * @param {String} name\n     * @return {Object}\n     * @api public\n     */\n    'getSearcher' : function (name) {\n      return Searchers[name];\n    },\n    /**\n     * Retrieve all Searchers.\n     */\n    'getSearchers' : function () {\n      return Searchers;\n    },\n    /**\n     * Loop through the indexes and provide the configuration.\n     *\n     * @param {Array|String} indexes\n     * @param callback\n     */\n    'eachIndex' : function (indexes, callback) {\n      indexes = !_.isArray(indexes) ? [indexes] : indexes;\n\n      _.each(indexes, function (index) {\n        callback(index, EasySearch.getIndex(index));\n      });\n    },\n    /**\n     * Makes it possible to override or extend the different\n     * types of search to use with EasySearch (the \"use\" property)\n     * when using EasySearch.createSearchIndex()\n     *\n     * @param {String} key      Type, e.g. mongo-db, elastic-search\n     * @param {Object} methods  Methods to be used, only 2 are required:\n     *                          - createSearchIndex (name, options)\n     *                          - search (name, searchString, [options, callback])\n     *                          - defaultQuery (options, searchString)\n     *                          - defaultSort (options)\n     */\n    'createSearcher' : function (key, methods) {\n      check(key, String);\n      check(methods.search, Function);\n      check(methods.createSearchIndex, Function);\n\n      Searchers[key] = methods;\n    },\n    /**\n     * Helper to check if searcher uses server side subscriptions for searching.\n     *\n     * @param {String} index Index name to check configuration for\n     */\n    '_usesSubscriptions' : function (index) {\n      var conf = EasySearch.getIndex(index);\n      return conf && conf.reactive && conf.use !== 'minimongo';\n    },\n    /**\n     * Helper to transform an array of fields to Meteor \"Field Specifiers\"\n     *\n     * @param {Array} fields Array of fields\n     */\n    '_transformToFieldSpecifiers' : function (fields) {\n      var specifiers = {};\n\n      _.each(fields, function (field) {\n        specifiers[field] = 1;\n      });\n\n      return specifiers;\n    }\n  };\n})();\n","Meteor.Collection.prototype.initEasySearch = function (fields, options) {\n  if (!_.isObject(options)) {\n    options = {};\n  }\n\n  EasySearch.createSearchIndex(this._name, _.extend(options, {\n    'collection' : this,\n    'field' : fields\n  }));\n};\n\nif (Meteor.isClient) {\n  jQuery.fn.esAutosuggestData = function () {\n    var input = $(this);\n\n    if (input.prop(\"tagName\").toUpperCase() !== 'INPUT') {\n      return [];\n    }\n\n    return EasySearch.getComponentInstance({'id': input.parent().data('id'), 'index': input.parent().data('index')}).get('autosuggestSelected');\n  }\n}\n","var methods = {\n  /**\n   * Set up a search index.\n   *\n   * @param name\n   * @param options\n   * @returns {void}\n   */\n  'createSearchIndex' : function (name, options) {\n    if (Meteor.isServer && options.useTextIndexes) {\n      var indexDoc = EasySearch._transformFieldsToIndexDocument(options.field),\n        rawCollection = EasySearch.getIndex(name).collection.rawCollection(),\n        indexOptions = { name: name };\n\n      if (options.weights) {\n        indexOptions.weights = options.weights();\n      }\n\n      rawCollection.createIndex(\n        indexDoc, indexOptions, function (err, res) {\n          options.onCreatedIndex && options.onCreatedIndex(res);\n        }\n      );\n    }\n  },\n  /**\n   *\n   * Perform a really simple search with mongo db.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   * @param {Function} callback\n   * @returns {Object}\n   */\n  'search' : function (name, searchString, options, callback) {\n    var cursor,\n      results,\n      selector,\n      pipeline,\n      aggregates,\n      cursorOptions,\n      index = EasySearch.getIndex(name);\n\n    if (!_.isObject(index)) {\n      return;\n    }\n\n    options.limit = options.limit || 10;\n\n    // if several, fields do an $or search, otherwise only over the field\n    selector = index.query(searchString, options);\n\n    if (!selector) {\n      return { total: 0, results: [] };\n    }\n\n    cursorOptions = {\n      sort : index.sort(searchString, options)\n    };\n\n    if (options.returnFields) {\n      cursorOptions.fields = EasySearch._transformToFieldSpecifiers(options.returnFields);\n    }\n\n    if (options.skip) {\n      cursorOptions.skip = options.skip;\n    }\n\n    if (Meteor.isServer) {\n      cursorOptions.limit = options.limit;\n    }\n\n    if (options.useTextIndexes) {\n      if (!cursorOptions.fields) {\n        cursorOptions.fields = {};\n      }\n\n      cursorOptions.fields.score = { $meta: 'textScore'  };\n    }\n\n    cursor = index.collection.find(selector, cursorOptions);\n\n    if (Meteor.isServer) {\n      // Get the total count by aggregating\n      pipeline = [\n        { $match: selector },\n        {\n          $group: { _id: \"id\", total: { $sum: 1 } }\n        }\n      ];\n\n      aggregates = index.collection.aggregate(pipeline);\n\n      results = {\n        'results': cursor.fetch(),\n        'total': aggregates.length >= 1 ? aggregates[0].total : 0\n      };\n    } else {\n      // The aggregate operations are not supported on client,\n      // so we have to explicitly count all records in the search result\n\n\n      results = {\n        'results' : _.first(cursor.fetch(), options.limit),\n        'total' : cursor.count()\n      };\n    }\n\n    if (_.isFunction(callback)) {\n      callback(results);\n    }\n\n    return results;\n  },\n  /**\n   * The default mongo-db query - selector used for searching.\n   *\n   * @param {Object} conf\n   * @param {String} searchString\n   * @param {Function} regexCallback\n   *\n   * @returns {Object}\n   */\n  'defaultQuery' : function (conf, searchString, regexCallback) {\n    if (Meteor.isServer && conf.useTextIndexes) {\n      return { $text: { $search: searchString } };\n    } else if (Meteor.isClient || !conf.useTextIndexes) {\n      // Convert numbers if configured\n      if (conf.convertNumbers && parseInt(searchString, 10) == searchString) {\n        searchString = parseInt(searchString, 10);\n      }\n\n      var stringSelector = { '$regex' : '.*' + searchString + '.*', '$options' : 'i'},\n        selector = {\n          $or: []\n        };\n\n      if (regexCallback) {\n        stringSelector['$regex'] = regexCallback(searchString);\n      }\n\n      _.each(conf.field, function (fieldString) {\n        var orSelector = {};\n\n        if (_.isString(searchString)) {\n          orSelector[fieldString] = stringSelector;\n        } else if (_.isNumber(searchString)) {\n          orSelector[fieldString] = searchString;\n        }\n\n        selector['$or'].push(orSelector);\n      });\n\n      return selector;\n    }\n  },\n  /**\n   * The default mongo-db sorting method used for sorting the results.\n   *\n   * @param {Object} conf\n   * @return array\n   */\n  'defaultSort' : function (conf) {\n    return conf.field;\n  }\n};\n\nif (Meteor.isClient) {\n  EasySearch.createSearcher('minimongo', methods);\n} else if (Meteor.isServer) {\n  EasySearch.createSearcher('mongo-db', methods);\n}\n\n","'use strict';\nvar ElasticSearch = Npm.require('elasticsearch');\n\nEasySearch._esDefaultConfig = {\n  host : 'localhost:9200'\n};\n\n/**\n * Override the config for Elastic Search.\n *\n * @param {object} newConfig\n */\nEasySearch.config = function (newConfig) {\n  if (\"undefined\" !== typeof newConfig) {\n    check(newConfig, Object);\n    this._config = _.extend(this._esDefaultConfig, newConfig);\n    this.ElasticSearchClient = new ElasticSearch.Client(this._config);\n  }\n\n  return this._config;\n};\n\n/**\n * Get the ElasticSearchClient\n * @see http://www.elasticsearch.org/guide/en/elasticsearch/client/javascript-api/current\n *\n * @return {ElasticSearch.Client}\n */\nEasySearch.getElasticSearchClient = function () {\n  return this.ElasticSearchClient;\n};\n\n/**\n * Transforms the field definition to a MongoDB index doc definition.\n *  \n * @param {Array} fields\n *\n * @returns {Object}\n */\nEasySearch._transformFieldsToIndexDocument = function (fields) {\n  var indexDoc = {};\n\n  _.each(fields, function (field) {\n    indexDoc[field] = 'text';\n  });\n\n  return indexDoc;\n};\n\nMeteor.methods({\n  /**\n   * Make server side search possible on the client.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   */\n  easySearch: function (name, searchString, options) {\n    check(name, String);\n    check(searchString, String);\n    check(options, Object);\n    return EasySearch.search(name, searchString, options);\n  }\n});\n","'use strict';\n\nvar Future = Npm.require('fibers/future'),\n  ElasticSearch = Npm.require('elasticsearch');\n\n/**\n * Return Elastic Search indexable data.\n *\n * @param {Object} doc the document to get the values from\n * @return {Object}\n */\nfunction getESFields(doc) {\n  var newDoc = {};\n\n  _.each(doc, function (value, key) {\n    newDoc[key] = _.isObject(value) && !_.isArray(value) && !_.isDate(value) ? JSON.stringify(value) : value;\n  });\n\n  return newDoc;\n}\n\nEasySearch.createSearcher('elastic-search', {\n  /**\n   * Write a document to a specified index.\n   *\n   * @param {String} name\n   * @param {Object} doc\n   * @param {String} id\n   * @param {Object} opts\n   * @param {Object} config\n   */\n  'writeToIndex' : function (name, doc, id, opts, config) {\n    var debugMode = config.debug,\n        transformedDoc = opts.transform(doc);\n\n    if (_.isObject(transformedDoc)) {\n      doc = transformedDoc;\n    }\n\n    // add to index\n    EasySearch.ElasticSearchClient.index({\n      index : name.toLowerCase(),\n      type : 'default',\n      id : id,\n      body : doc\n    }, function (err, data) {\n      if (err) {\n        console.log('Had error adding a document!');\n        console.log(err);\n      }\n\n      if (debugMode && console) {\n        console.log('EasySearch: Added / Replaced document to Elastic Search:');\n        console.log('EasySearch: ' + data + \"\\n\");\n      }\n    });\n  },\n  /**\n   * Setup some observers on the mongo db collection provided.\n   *\n   * @param {String} name\n   * @param {Object} options\n   */\n  'createSearchIndex' : function (name, options) {\n    var searcherScope = this,\n      config = EasySearch.config() || {};\n\n    if (\"undefined\" === typeof EasySearch.ElasticSearchClient) {\n      EasySearch.ElasticSearchClient = new ElasticSearch.Client(this._esDefaultConfig);\n    }\n\n    name = name.toLowerCase();\n\n    options.collection.find().observeChanges({\n      added: function (id, fields) {\n        searcherScope.writeToIndex(name, getESFields(fields), id, options, config);\n      },\n      changed: function (id) {\n        // Overwrites the current document with the new doc\n        searcherScope.writeToIndex(name, getESFields(options.collection.findOne(id)), id, options, config);\n      },\n      removed: function (id) {\n        EasySearch.ElasticSearchClient.delete({\n          index: name,\n          type: 'default',\n          id: id\n        }, function (error, response) {\n          if (config.debug) {\n            console.log('Removed document with id ( ' +  id + ' )!');\n          }\n        });\n      }\n    });\n  },\n  /**\n   * Get the data out of the JSON elastic search response.\n   *\n   * @param {Object} data\n   * @returns {Array}\n   */\n  'extractJSONData' : function (data) {\n    data = _.isString(data) ? JSON.parse(data) : data;\n\n    var results = _.map(data.hits.hits, function (resultSet) {\n      var field = '_source';\n\n      if (resultSet['fields']) {\n        field = 'fields';\n      }\n\n      resultSet[field]['_id'] = resultSet['_id'];\n      return resultSet[field];\n    });\n\n    return {\n      'results' : results,\n      'total' : data.hits.total\n    };\n  },\n  /**\n   * Perform a search with Elastic Search, using fibers.\n   *\n   * @param {String} name\n   * @param {String} searchString\n   * @param {Object} options\n   * @param {Function} callback\n   * @returns {*}\n   */\n  'search' : function (name, searchString, options, callback) {\n    var bodyObj,\n      that = this,\n      fut = new Future(),\n      index = EasySearch.getIndex(name);\n\n    if (!_.isObject(index)) {\n      return;\n    }\n\n    bodyObj = {\n      \"query\" : index.query(searchString, options)\n    };\n\n    if (!bodyObj.query) {\n      return { total: 0, results: [] };\n    }\n\n    bodyObj.sort = index.sort(searchString, options);\n\n    if (options.returnFields) {\n      if (options.returnFields.indexOf('_id') === -1 ) {\n        options.returnFields.push('_id');\n      }\n\n      bodyObj.fields = options.returnFields;\n    }\n\n    // Modify Elastic Search body if wished\n    if (index.body && _.isFunction(index.body)) {\n      bodyObj = index.body(bodyObj, options);\n    }\n\n    name = name.toLowerCase();\n\n    if (\"function\" === typeof callback) {\n      EasySearch.ElasticSearchClient.search(name, bodyObj, callback);\n      return;\n    }\n\n    // Most likely client call, return data set\n    EasySearch.ElasticSearchClient.search({\n      index : name,\n      body : bodyObj,\n      size : options.limit,\n      from: options.skip\n    }, function (error, data) {\n      if (error) {\n        console.log('Had an error while searching!');\n        console.log(error);\n        return;\n      }\n\n      if (\"raw\" !== index.format) {\n        data = that.extractJSONData(data);\n      }\n\n      fut['return'](data);\n    });\n\n    return fut.wait();\n  },\n  /**\n   * The default ES query object used for searching the results.\n   *\n   * @param {Object} options\n   * @param {String} searchString\n   * @return array\n   */\n  'defaultQuery' : function (options, searchString) {\n    return {\n      \"fuzzy_like_this\" : {\n        \"fields\" : options.field,\n        \"like_text\" : searchString\n      }\n    };\n  },\n  /**\n   * The default ES sorting method used for sorting the results.\n   *\n   * @param {Object} options\n   * @return array\n   */\n  'defaultSort' : function (options) {\n    return options.field;\n  }\n});\n\n// Expose ElasticSearch API\nEasySearch.ElasticSearch = ElasticSearch;\n"]}